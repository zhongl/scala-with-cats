@inproceedings{10.1145/325694.325708,
author = {Lewis, Jeffrey R. and Launchbury, John and Meijer, Erik and Shields, Mark B.},
title = {Implicit parameters: dynamic scoping with static types},
year = {2000},
isbn = {1581131259},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/325694.325708},
doi = {10.1145/325694.325708},
abstract = {This paper introduces a language feature, called implicit parameters, that provides dynamically scoped variables within a statically-typed Hindley-Milner framework. Implicit parameters are lexically distinct from regular identifiers, and are bound by a special with construct whose scope is dynamic, rather than static as with let. Implicit parameters are treated by the type system as parameters that are not explicitly declared, but are inferred from their use.We present implicit parameters within a small call-by-name λ-calculus. We give a type system, a type inference algorithm, and several semantics. We also explore implicit parameters in the wider settings of call-by-need languages with overloading, and call-by-value languages with effects. As a witness to the former, we have implemented implicit parameters as an extension of Haskell within the Hugs interpreter, which we use to present several motivating examples.},
booktitle = {Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {108–118},
numpages = {11},
location = {Boston, MA, USA},
series = {POPL '00}
}

@inproceedings{10.1145/75277.75283,
author = {Wadler, P. and Blott, S.},
title = {How to make ad-hoc polymorphism less ad hoc},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75283},
doi = {10.1145/75277.75283},
abstract = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {60–76},
numpages = {17},
location = {Austin, Texas, USA},
series = {POPL '89}
}

@InProceedings{10.1007/3-540-19027-9_9,
author="Kaes, Stefan",
editor="Ganzinger, H.",
title="Parametric overloading in polymorphic programming languages",
booktitle="ESOP '88",
year="1988",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="131--144",
abstract="The introduction of unrestricted overloading in languages with type systems based on implicit parametric polymorphism generally destroys the principal type property: namely that the type of every expression can uniformly be represented by a single type expression over some set of type variables. As a consequence, type inference in the presence of unrestricted overloading can become a NP-complete problem. In this paper we define the concept of parametric overloading as a restricted form of overloading which is easily combined with parametric polymorphism. Parametric overloading preserves the principal type property, thereby allowing the design of efficient type inference algorithms. We present sound type deduction systems, both for predefined and programmer defined overloading. Finally we state that parametric overloading can be resolved either statically, at compile time, or dynamically, during program execution.",
isbn="978-3-540-38941-5"
}

@inproceedings{10.1145/1869459.1869489,
author = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
title = {Type classes as objects and implicits},
year = {2010},
isbn = {9781450302036},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1869459.1869489},
doi = {10.1145/1869459.1869489},
abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {341–360},
numpages = {20},
keywords = {abstract datatypes, c++ concepts, scala, type classes},
location = {Reno/Tahoe, Nevada, USA},
series = {OOPSLA '10}
}

@inproceedings{10.1145/99370.99404,
author = {Wadler, Philip},
title = {Theorems for free!},
year = {1989},
isbn = {0897913280},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/99370.99404},
doi = {10.1145/99370.99404},
booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
pages = {347–359},
numpages = {13},
location = {Imperial College, London, United Kingdom},
series = {FPCA '89}
}

@article{10.1145/3360589,
author = {K\v{r}ikava, Filip and Miller, Heather and Vitek, Jan},
title = {Scala implicits are everywhere: a large-scale study of the use of Scala implicits in the wild},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360589},
doi = {10.1145/3360589},
abstract = {The Scala programming language offers two distinctive language features implicit parameters and implicit conversions, often referred together as implicits. Announced without fanfare in 2004, implicits have quickly grown to become a widely and pervasively used feature of the language. They provide a way to reduce the boilerplate code in Scala programs. They are also used to implement certain language features without having to modify the compiler. We report on a large-scale study of the use of implicits in the wild. For this, we analyzed 7,280 Scala projects hosted on GitHub, spanning over 8.1M call sites involving implicits and 370.7K implicit declarations across 18.7M lines of Scala code.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {163},
numpages = {28},
keywords = {Implicit parameters, Scala, corpora analysis, implicit conversions}
}

@article{OLIVEIRA_GIBBONS_2010
, title={Scala for generic programmers: Comparing Haskell and Scala support for generic programming}
, volume={20}
, DOI={10.1017/S0956796810000171}
, url={https://www.cambridge.org/core/journals/journal-of-functional-programming/article/scala-for-generic-programmers/223EB37E77EA36B27AE33A644DA70926}
, number={3–4}
, journal={Journal of Functional Programming}
, author={Oliveira, Bruno C. D. S. and Gibbons, Jeremy}
, year={2010}
, pages={303–352}
}

@article{10.1145/3158130,
author = {Odersky, Martin and Blanvillain, Olivier and Liu, Fengyun and Biboudis, Aggelos and Miller, Heather and Stucki, Sandro},
title = {Simplicitly: foundations and applications of implicit function types},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158130},
doi = {10.1145/3158130},
abstract = {Understanding a program entails understanding its context; dependencies, configurations and even implementations are all forms of contexts. Modern programming languages and theorem provers offer an array of constructs to define contexts, implicitly. Scala offers implicit parameters which are used pervasively, but which cannot be abstracted over. This paper describes a generalization of implicit parameters to implicit function types, a powerful way to abstract over the context in which some piece of code is run. We provide a formalization based on bidirectional type-checking that closely follows the semantics implemented by the Scala compiler. To demonstrate their range of abstraction capabilities, we present several applications that make use of implicit function types. We show how to encode the builder pattern, tagless interpreters, reader and free monads and we assess the performance of the monadic structures presented.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {42},
numpages = {29},
keywords = {implicit parameters, Scala, Dotty}
}


@Book{felleisen18:htdp,
  author          = {Matthias Felleisen and Robert Bruce Findler and Matthew Flatt and Shriram Krishnamurthi},
  title           = {How to Design Programs, Second Edition},
  year            = {2018},
  subtitle     = {An Introductino to Programming and Computing},
  publisher    = {The MIT Press},
  isbn         = 9780262534802,
  url          = {https://htdp.org/}}


@InProceedings{10.1007/3540543961_7,
author="Meijer, Erik
and Fokkinga, Maarten
and Paterson, Ross",
editor="Hughes, John",
title="Functional programming with bananas, lenses, envelopes and barbed wire",
booktitle="Functional Programming Languages and Computer Architecture",
year="1991",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="124--144",
abstract="We develop a calculus for lazy functional programming based on recursion operators associated with data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's ``Introduction to Functional Programming'' can be expressed using these operators.",
isbn="978-3-540-47599-6",
url={https://ris.utwente.nl/ws/portalfiles/portal/6142049/meijer91functional.pdf}
}

@article{10.1093/comjnl/12.1.41,
    author = {Burstall, R. M.},
    title = "{Proving Properties of Programs by Structural Induction}",
    journal = {The Computer Journal},
    volume = {12},
    number = {1},
    pages = {41-48},
    year = {1969},
    month = {02},
    abstract = "{This paper discusses the technique of structural induction for proving theorems about programs. This technique is closely related to recursion induction but makes use of the inductive definition of the data structures handled by the programs. It treats programs with recursion but without assignments or jumps. Some syntactic extensions to Landin's functional programming language ISWIM are suggested which make it easier to program the manipulation of data structures and to develop proofs about such programs. Two sample proofs are given to demonstrate the technique, one for a tree sorting algorithm and one for a simple compiler for expressions.}",
    issn = {0010-4620},
    doi = {10.1093/comjnl/12.1.41},
    url = {https://doi.org/10.1093/comjnl/12.1.41},
    eprint = {https://academic.oup.com/comjnl/article-pdf/12/1/41/885019/12-1-41.pdf},
}

@article{GIBBONS_2021,
 title={How to design co-programs},
 volume={31},
 DOI={10.1017/S0956796821000113},
 journal={Journal of Functional Programming},
 author={Gibbons, Jeremy},
 year={2021},
 pages={e15}
}

@inproceedings{10.1145/289423.289455,
author = {Gibbons, Jeremy and Jones, Geraint},
title = {The under-appreciated unfold},
year = {1998},
isbn = {1581130244},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/289423.289455},
doi = {10.1145/289423.289455},
abstract = {Folds are appreciated by functional programmers. Their dual, unfolds, are not new, but they are not nearly as well appreciated. We believe they deserve better. To illustrate, we present (indeed, we calculate) a number of algorithms for computing the breadth-first traversal of a tree. We specify breadth-first traversal in terms of level-order traversal, which we characterize first as a fold. The presentation as a fold is simple, but it is inefficient, and removing the inefficiency makes it no longer a fold. We calculate a characterization as an unfold from the characterization as a fold; this unfold is equally clear, but more efficient. We also calculate a characterization of breadth-first traversal directly as an unfold; this turns out to be the 'standard' queue-based algorithm.},
booktitle = {Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming},
pages = {273–279},
numpages = {7},
keywords = {anamorphism, breadth-first, co-induction, fold, functional programing, level-order, program calculation, traversal, unfold},
location = {Baltimore, Maryland, USA},
series = {ICFP '98}
}

@article{10.1145/291251.289455,
author = {Gibbons, Jeremy and Jones, Geraint},
title = {The under-appreciated unfold},
year = {1998},
issue_date = {Jan. 1999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/291251.289455},
doi = {10.1145/291251.289455},
abstract = {Folds are appreciated by functional programmers. Their dual, unfolds, are not new, but they are not nearly as well appreciated. We believe they deserve better. To illustrate, we present (indeed, we calculate) a number of algorithms for computing the breadth-first traversal of a tree. We specify breadth-first traversal in terms of level-order traversal, which we characterize first as a fold. The presentation as a fold is simple, but it is inefficient, and removing the inefficiency makes it no longer a fold. We calculate a characterization as an unfold from the characterization as a fold; this unfold is equally clear, but more efficient. We also calculate a characterization of breadth-first traversal directly as an unfold; this turns out to be the 'standard' queue-based algorithm.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {273–279},
numpages = {7},
keywords = {anamorphism, breadth-first, co-induction, fold, functional programing, level-order, program calculation, traversal, unfold}
}

@Unpublished{mcbride01:deriv,
  author          = {Conor McBride},
  title           = {The Derivative of a Regular Type is its Type of One-Hole Contexts},
  year            = 2001,
  url          = {http://strictlypositive.org/diff.pdf}}


@article{HAGINO1989629,
title = {Codatatypes in ML},
journal = {Journal of Symbolic Computation},
volume = {8},
number = {6},
pages = {629-650},
year = {1989},
issn = {0747-7171},
doi = {https://doi.org/10.1016/S0747-7171(89)80065-3},
url = {https://www.sciencedirect.com/science/article/pii/S0747717189800653},
author = {Tatsuya Hagino},
abstract = {A new data type declaration mechanism of defining codatatypes is introduced to a functional programming language ML. Codatatypes are dual to datatypes for which ML already has a mechanism of defining. Sums and finite lists are defined as datatypes, but their duals, products and infinite lists, could not be defined in ML. This new facility gives ML the missing half of data types and makes ML symmetric. Categorical and domain-theoretic characterization of codatatypes are also given.}
}

@inproceedings{downen2019codata,
  title={Codata in action},
  author={Downen, Paul and Sullivan, Zachary and Ariola, Zena M and Peyton Jones, Simon},
  booktitle={European Symposium on Programming},
  pages={119--146},
  year={2019},
  organization={Springer International Publishing Cham},
  url={https://www.microsoft.com/en-us/research/uploads/prod/2020/01/CoDataInAction.pdf}
}

@techreport {DRP-201905-Sullivan,
   type = {Directed Research Project},
   author = {Zachary Sullivan},
   title = {Exploring Codata: The Relation to Object-Orientation},
   institution = {University of Oregon, Computer and Information Sciences Department},
   number = DRP-201905-Sullivan,
   month = 5,
   year = 2019,
   url={https://www.cs.uoregon.edu/Reports/DRP-201905-Sullivan.pdf}
}

@inproceedings{wadler1998add,
  title={How to add laziness to a strict language without even being odd},
  author={Wadler, Philiip and Taha, Walid and MacQueen, David},
  booktitle={SML'98, The SML workshop},
  year={1998},
  url={https://www.diva-portal.org/smash/get/diva2:413532/FULLTEXT01.pdf}
}

@article{DBLP:journals/corr/abs-2103-06913,
  author       = {Paul Downen and Zena M. Ariola},
  title        = {Classical (Co)Recursion: Programming},
  journal      = {CoRR},
  volume       = {abs/2103.06913},
  year         = {2021},
  url          = {https://arxiv.org/abs/2103.06913},
  eprinttype    = {arXiv},
  eprint       = {2103.06913},
  timestamp    = {Thu, 14 Oct 2021 09:14:34 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2103-06913.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@unpublished{kiselyov05:beyond,
  author       = {Oleg Kiselyov},
  title           = {Beyond Church encoding: Boehm-Berarducci isomorphism of algebraic data types and polymorphic lambda-terms},
  year            = 2005,
  url          = {https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html}}

@inproceedings{10.1145/800194.805852,
author = {Reynolds, John C.},
title = {Definitional interpreters for higher-order programming languages},
year = {1972},
isbn = {9781450374927},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800194.805852},
doi = {10.1145/800194.805852},
abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
booktitle = {Proceedings of the ACM Annual Conference - Volume 2},
pages = {717–740},
numpages = {24},
keywords = {Applicative language, Closure, Continuation, GEDANKEN, Higher-order function, Interpreter, J-operator, LISP, Lambda calculus, Language definition, Order of application, PAL, Programming language, Reference, SECD machine},
location = {Boston, Massachusetts, USA},
series = {ACM '72}
}

@inproceedings{10.1145/773184.773202,
author = {Danvy, Olivier and Nielsen, Lasse R.},
title = {Defunctionalization at work},
year = {2001},
isbn = {158113388X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/773184.773202},
doi = {10.1145/773184.773202},
abstract = {Reynolds's defunctionalization technique is a whole-program transformation from higher-order to first-order functional programs. We study practical applications of this transformation and uncover new connections between seemingly unrelated higher-order and first-order specifications and between their correctness proofs. Defunctionalization therefore appearsboth as a springboard for rev ealing new connections and as a bridge for transferring existing results between the first-order world and the higher-order world.},
booktitle = {Proceedings of the 3rd ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
pages = {162–174},
numpages = {13},
keywords = {syntactic theories, supercombinator conversion, regular expressions, lambda-lifting, higher-order programs, first-order programs, direct-style transformation, defunctionalization, continuations, continuation-passing style (CPS), closure conversion, church encoding, Scheme, ML, CPS transformation},
location = {Florence, Italy},
series = {PPDP '01}
}

@Article{gibbons22:cps,
  author          = {Jeremy Gibbons},
  title           = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  journaltitle    = {The Art, Science, and Engineering of Programming},
  year            = 2022,
  volume       = 6,
  number       = 7,
  issue        = 2,
  doi          = {https://doi.org/10.22152/programming-journal.org/2022/6/7}}
